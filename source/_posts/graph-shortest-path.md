title: 基础图论-最短路径算法总结
date: 2016-02-19 15:35:00
tags: 
- 最短路径
- Bellman-Ford
- Dijkstra
- SPFA
- Floyd-Washall

categories:
- algorithm
---
最短路径问题是图论中基础问题，本文对多种最短路径算法原理进行简单总结，并从实现和复杂度上进行比较。

## 单源最短路径
单源最短路径问题: 给定图G，源点s，求s到其他各个顶点的最短路径。

### Bellman-Ford算法
图G中如果不存在负环，考虑s出发到其他各个节点，其最短路径将形成一个树（所谓前趋子图）。且该树的最大深度为|V|-1。那么可以通过“松弛”技术来更新其他点到s的距离。
> 松弛操作
> dist[v] = min(dist[u] + e(u,v), dist[v])

因为无负环情况下，路径最长边数为|V|-1，那么每次对所有dist[v]进行松弛，最多执行|V|-1次将收敛。

倘若第|V|次对所有顶点进行松弛操作，仍有更新，那么该图中存在负环。
所以Bellman-Ford算法也可以用来检测图中是否有负环。

复杂度分析比较简单，每次松弛操作O(|E|)，总时间复杂度O(|V||E|)。

### Bellman-Ford算法C++代码



### Dijkstra算法

Dijkstra 算法适用于无负环图。考虑Bellman-Ford算法中，每次对所有边进行松弛操作，对于已算出最短路径的顶点是一种浪费。

而Dijkstra算法维护一个点集V'，初始为{s}，每次将当前最短路径的点加入其中，然后从该点出发，对未加入点进行松弛操作。

这样通过|V|-1次加入顶点的操作，就能获得从s点到其他点的最短路径。

当图中所有权重相等时，Dijkstra算法退化成BFS算法。

### Dijkstra算法简单证明
定义：V为顶点全集，dist[v]表示算法执行时，顶点v的路径长度。
下面证明：在Djikstra算法中，每次向V'加入顶点u后，dist[u]的值等于最短路径长度。
初始：V'={s} 显然成立
保持：考虑在V-V'中，u为当前路径长度最短的点，v为除u之外任意点，先证明u必然先于v加入V'。
假设v先加入V'，那
终止：

### Dijkstra算法C++代码


### Dijkstra算法复杂度
松弛操作的总开销为O(|E|)。

每次选取当前最短路径的点，线性扫描的方式为O(|V|)，采用二叉堆的开销为O(log|V|)。
两种方式总开销分别为O(|V|^2)和O(|V|log|V|)。

所以线性扫描，总时间复杂度为O(|E|) + O(|V|^2) = O(|V|^2)

而采用二叉堆在松弛后需要进行O(E)次入队操作，每次开销为O(log|V|)，故总复杂度为O(|E|) + O(|V|log|V|) + O(|E|log|V|) = O(|E|log|V|)。

### SPFA 算法
SPFA(Shortest Path Faster Algorithm) 算法，在Bellman-Ford算法上加了一个队列优化。
在图存在负环的情况下，Dijkstra算法不适用，而Bellman-Ford算法复杂度太高，该算法就是较好的选择。

算法维护一个队列，该队列初始状态下将s入队，每次用出队的顶点u进行松弛操作；如果有一个顶点v松弛成功更新了（比当前距离小），并且不在当前队列中，那么将v入队尾。

在没有负环的情况下，每次入队能够保证减小dist[v]，直到队列为空，最终能够获得所有顶点的最短路径。算法复杂度O(n*|E|)，n为顶点平均入队次数，而入队次数取决于图的边权分布。算法运行时间不稳定，最坏的情况下，为Bellman-Ford算法。

可能有负环的情况下，记录每个顶点的入队次数，如果存在顶点入队次数达到|V|，那么一定存在负环。

实际运用中通过SLF(Smallest Label First)或LLL(Large Label Last)优化，一般比原算法有一定提升。关于SPFA的详细介绍：
//TODO

### SPFA算法C++代码



## 多源最短路径
### Floyd-Washall 算法
给定一个图G，任意两点u,v的路径可能经过所有其他点。该算法利用了动态规划思想，求图中任意两点最短路径的问题。
> 考虑G中点(v0, v1, v2, ..., vn)的前K个，uv中经过前K个顶点的最短距离dist[k][u][v]可以分解为：
> 1. 经过点k，那么dist[k][u][v] = dist[k-1][u][k] + dist[k-1][k][v]
> 2. 不经过k，那么dist[k][u][v] = dist[k-1][u][v]
> 递推式: dist[k][u][v] = min( dist[k-1][u][k] + dist[k-1][k][v], dist[k-1][u][v])
有了上述递推公式，就可以自底向上进行动态规划求解。算法复杂度为O(|V|^3)。



## 最短路径的还原
对于每次松弛操作，为每个顶点v记录father[v] = u，表示当前路径最后一步，u经e(u, v)到达v。
在最短路径算法完成后，沿father[v]进行回溯就可以还原出整条路径。